<!DOCTYPE html>
<html lang="pl">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Akumulator Piaskowy - ZarzÄ…dzanie EnergiÄ…</title>
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/papaparse@5.4.1/papaparse.min.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            padding: 20px;
            min-height: 100vh;
        }

        .container {
            max-width: 1400px;
            margin: 0 auto;
            background: white;
            border-radius: 20px;
            padding: 30px;
            box-shadow: 0 20px 60px rgba(0,0,0,0.3);
        }

        h1 {
            text-align: center;
            color: #333;
            margin-bottom: 10px;
            font-size: 2.5em;
        }

        .subtitle {
            text-align: center;
            color: #666;
            margin-bottom: 30px;
            font-size: 1.1em;
        }

        .controls {
            background: #f8f9fa;
            padding: 25px;
            border-radius: 15px;
            margin-bottom: 30px;
        }

        .control-group {
            margin-bottom: 20px;
        }

        .control-group label {
            display: block;
            margin-bottom: 8px;
            font-weight: 600;
            color: #333;
        }

        .control-row {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 15px;
        }

        input[type="number"], input[type="range"], select {
            width: 100%;
            padding: 10px;
            border: 2px solid #ddd;
            border-radius: 8px;
            font-size: 1em;
            transition: border-color 0.3s;
        }

        input[type="number"]:focus, select:focus {
            outline: none;
            border-color: #667eea;
        }

        input[type="range"] {
            padding: 5px;
        }


        .button-group {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 15px;
            margin-top: 20px;
        }

        button {
            padding: 15px 20px;
            border: none;
            border-radius: 8px;
            font-size: 0.95em;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s;
            color: white;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }


        button.success {
            background: linear-gradient(135deg, #11998e 0%, #38ef7d 100%);
        }

        button:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(0,0,0,0.3);
        }

        button:active {
            transform: translateY(0);
        }

        .charts-container {
            display: grid;
            grid-template-columns: 1fr;
            gap: 30px;
            margin-top: 30px;
        }

        .chart-wrapper {
            background: #f8f9fa;
            padding: 20px;
            border-radius: 15px;
            box-shadow: 0 3px 10px rgba(0,0,0,0.1);
        }

        .chart-title {
            font-size: 1.3em;
            font-weight: 600;
            color: #333;
            margin-bottom: 15px;
            text-align: center;
        }

        canvas {
            max-height: 400px;
        }
        .info-box {
            background: #e3f2fd;
            border-left: 4px solid #2196f3;
            padding: 15px;
            margin-bottom: 20px;
            border-radius: 5px;
        }

        .info-box h3 {
            color: #1976d2;
            margin-bottom: 10px;
        }

        .info-box p {
            color: #555;
            line-height: 1.6;
        }

        @media (max-width: 768px) {
            .container {
                padding: 15px;
            }

            h1 {
                font-size: 1.8em;
            }


            .button-group {
                grid-template-columns: 1fr;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>âš¡ Akumulator Piaskowy</h1>
        <p class="subtitle">System zarzÄ…dzania energiÄ… z fotowoltaiki</p>

        <div class="info-box">
            <h3>â„¹ï¸ O systemie</h3>
            <p>Akumulator piaskowy to system przechowywania energii termicznej. Energia z paneli fotowoltaicznych jest przeksztaÅ‚cana w ciepÅ‚o i magazynowana w piasku, ktÃ³ry moÅ¼e osiÄ…gnÄ…Ä‡ temperatury do 600Â°C. System moÅ¼e nastÄ™pnie oddawaÄ‡ ciepÅ‚o do ogrzewania lub produkcji energii elektrycznej.</p>
            <p><strong>Symulacja rozpoczyna siÄ™ od pustego akumulatora (0 kWh, 20Â°C)</strong> i stopniowo gromadzi energiÄ™ z instalacji PV. System uwzglÄ™dnia:</p>
            <ul style="margin: 5px 0 10px 20px; line-height: 1.6;">
                <li><strong>KsztaÅ‚t zbiornika:</strong> prostopadÅ‚oÅ›cian lub walec (rÃ³Å¼ne obliczenia powierzchni i strat)</li>
                <li>Straty cieplne przez izolacjÄ™ (im grubsza, tym mniejsze)</li>
                <li>Gradient temperatury w piasku (centrum â†’ Å›cianki)</li>
                <li><strong>Skalowanie produkcji PV</strong> (100% = peÅ‚na moc z pliku, 50% = poÅ‚owa produkcji)</li>
            </ul>
            <p><strong>ğŸ’¡ Start:</strong> Aplikacja automatycznie wczyta przykÅ‚adowe dane produkcji (instalacja 10kW). MoÅ¼esz teÅ¼ kliknÄ…Ä‡ <strong>"ğŸ“ Wybierz plik CSV"</strong> aby wczytaÄ‡ wÅ‚asne dane.</p>
            <p style="margin-top: 10px; font-size: 0.9em;"><strong>ğŸ“ Format CSV:</strong> Kolumny <code>time</code> (data) i <code>daily-production</code> (produkcja w kWh).</p>
            <p style="margin-top: 5px; font-size: 0.9em;"><strong>â° ObsÅ‚ugiwane formaty dat:</strong></p>
            <ul style="margin: 5px 0 10px 20px; line-height: 1.6; font-size: 0.9em;">
                <li><strong>Jeden wpis dziennie:</strong> <code>2025-07-29</code> lub <code>2025-07-29,10.5</code></li>
                <li><strong>Wiele wpisÃ³w dziennie (z timestampami):</strong> <code>2025-07-29 20:37:03,0.00046</code> - wartoÅ›ci zostanÄ… automatycznie zsumowane per dzieÅ„</li>
            </ul>
            <p style="margin-top: 10px; font-size: 0.9em;"><strong>ğŸ”§ Debug:</strong> JeÅ›li masz problem, otwÃ³rz konsolÄ™ przeglÄ…darki (F12) aby zobaczyÄ‡ szczegÃ³Å‚y.</p>
        </div>

        <div class="info-box" style="background: #fff3e0; border-left-color: #ff9800;">
            <h3 style="color: #e65100;">ğŸ”¬ Parametry fizyczne materiaÅ‚Ã³w</h3>
            <p><strong>Piasek (medium magazynujÄ…ce):</strong></p>
            <ul style="margin: 5px 0 10px 20px; line-height: 1.8;">
                <li>PrzewodnoÅ›Ä‡ cieplna Î»: <strong>0.27 W/(mÂ·K)</strong> (piasek suchy)</li>
                <li>GÄ™stoÅ›Ä‡: 1600 kg/mÂ³</li>
                <li>CiepÅ‚o wÅ‚aÅ›ciwe: 0.835 kJ/(kgÂ·K)</li>
                <li>Zakres temperatur: 20Â°C - <strong>max (konfigurowalna, domyÅ›lnie 600Â°C)</strong></li>
                <li><strong>Gradient temperatury:</strong> centrum (max) â†’ Å›rednia â†’ Å›cianki (min, przed izolacjÄ…)</li>
            </ul>
            <p><strong>Izolacja zewnÄ™trzna (weÅ‚na mineralna):</strong></p>
            <ul style="margin: 5px 0 10px 20px; line-height: 1.8;">
                <li>PrzewodnoÅ›Ä‡ cieplna Î»: <strong>0.04 W/(mÂ·K)</strong></li>
                <li>GruboÅ›Ä‡: konfigurowana (domyÅ›lnie 200 mm)</li>
                <li><strong>Izolacja podstawy: 4Ã— grubsza</strong> (konstrukcyjna, np. bloczki betonowe noÅ›ne)</li>
                <li>EfektywnoÅ›Ä‡: ~6.75Ã— lepsza izolacja niÅ¼ piasek</li>
            </ul>
            <p><strong>Warunki brzegowe:</strong></p>
            <ul style="margin: 5px 0 10px 20px; line-height: 1.8;">
                <li>Temperatura otoczenia: <strong>20Â°C</strong> (staÅ‚a)</li>
                <li>Model: przewodzenie ciepÅ‚a przez warstwy szeregowo</li>
                <li>Åšrednia droga ciepÅ‚a w piasku: (L+W+H)/6 [m]</li>
                <li><strong>RozkÅ‚ad temp. w piasku:</strong> paraboliczny (T_avg = (2Ã—T_center + T_wall)/3)</li>
            </ul>
            <p style="margin-top: 10px; font-size: 0.9em;"><strong>ğŸ“Š Model strat:</strong> Q = Î”T / (R_piasek + R_izolacja), gdzie R = d/(Î»Â·A). Gradient temp. powoduje Å¼e Å›rednia temp. piasku jest niÅ¼sza niÅ¼ w centrum.</p>
        </div>



        <div class="controls">
            <h2 style="margin-bottom: 20px; color: #333;">âš™ï¸ Konfiguracja systemu</h2>

            <div class="control-row">
                <div class="control-group">
                    <label for="tankShape">KsztaÅ‚t zbiornika:</label>
                    <select id="tankShape" style="padding: 8px; border: 1px solid #ddd; border-radius: 5px; font-size: 1em;">
                        <option value="box">ProstopadÅ‚oÅ›cian</option>
                        <option value="cylinder">Walec</option>
                    </select>
                </div>
            </div>

            <div id="boxDimensions" class="control-row">
                <div class="control-group">
                    <label for="tankLength">DÅ‚ugoÅ›Ä‡ zbiornika (m):</label>
                    <input type="number" id="tankLength" value="1" min="0.1" max="50" step="0.1">
                </div>

                <div class="control-group">
                    <label for="tankWidth">SzerokoÅ›Ä‡ zbiornika (m):</label>
                    <input type="number" id="tankWidth" value="1" min="0.1" max="50" step="0.1">
                </div>

                <div class="control-group">
                    <label for="tankHeight">WysokoÅ›Ä‡ zbiornika (m):</label>
                    <input type="number" id="tankHeight" value="1" min="0.1" max="50" step="0.1">
                </div>
            </div>

            <div id="cylinderDimensions" class="control-row" style="display: none;">
                <div class="control-group">
                    <label for="cylinderRadius">PromieÅ„ walca (m):</label>
                    <input type="number" id="cylinderRadius" value="0.564" min="0.1" max="50" step="0.01">
                    <small style="display: block; color: #666; margin-top: 5px;">PromieÅ„ 0.564m â‰ˆ objÄ™toÅ›Ä‡ 1mÂ³ przy wys. 1m</small>
                </div>

                <div class="control-group">
                    <label for="cylinderHeight">WysokoÅ›Ä‡ walca (m):</label>
                    <input type="number" id="cylinderHeight" value="1" min="0.1" max="50" step="0.1">
                </div>
            </div>

            <div class="control-row">
                <div class="control-group">
                    <label for="insulationThickness">GruboÅ›Ä‡ izolacji (mm):</label>
                    <input type="number" id="insulationThickness" value="200" min="0" max="1000" step="10">
                    <small style="display: block; color: #666; margin-top: 5px;">Uwaga: izolacja podstawy bÄ™dzie 4Ã— grubsza (konstrukcyjna, np. bloczki betonowe noÅ›ne)</small>
                </div>

                <div class="control-group">
                    <label for="maxSandTemp">Maksymalna temperatura piasku (Â°C):</label>
                    <input type="number" id="maxSandTemp" value="600" min="100" max="1000" step="50">
                    <small style="display: block; color: #666; margin-top: 5px;">Typowo: 500-600Â°C. WyÅ¼sza temp. = wiÄ™ksza pojemnoÅ›Ä‡, ale trudniejsza realizacja</small>
                </div>
            </div>

            <div class="control-row">
                <div class="control-group">
                    <label for="pvScaling">Skalowanie produkcji PV (%):</label>
                    <input type="number" id="pvScaling" value="100" min="0" max="200" step="1">
                    <small style="display: block; color: #666; margin-top: 5px;">100% = peÅ‚na produkcja z pliku. 50% = poÅ‚owa produkcji.</small>
                </div>
            </div>


            <h3 style="margin-top: 20px; color: #333; font-size: 1.1em;">ğŸ® Sterowanie:</h3>
            <div class="button-group">
                <button class="success" onclick="document.getElementById('fileInput').click()">ğŸ“ Wybierz plik CSV</button>
            </div>
            <input type="file" id="fileInput" accept=".csv" style="display: none;" onchange="loadFromFile(event)">
            <p style="margin-top: 10px; color: #666; font-size: 0.9em;">
                ğŸ’¡ <strong>WskazÃ³wka:</strong> PrzykÅ‚adowe dane (10kW) wczytajÄ… siÄ™ automatycznie. UÅ¼yj przycisku aby wczytaÄ‡ wÅ‚asny plik CSV.
            </p>
        </div>

        <div class="charts-container">
            <div class="chart-wrapper">
                <h3 class="chart-title">ğŸ”‹ Stan akumulatora - caÅ‚y okres</h3>
                <canvas id="storageChart"></canvas>
            </div>

            <div class="chart-wrapper">
                <h3 class="chart-title">ğŸ“‰ Straty energii przez izolacjÄ™ - caÅ‚y okres</h3>
                <canvas id="lossChart"></canvas>
            </div>

            <div class="chart-wrapper">
                <h3 class="chart-title">ğŸŒ¡ï¸ Temperatura piasku (centrum, Å›rednia, Å›cianki) - caÅ‚y okres</h3>
                <canvas id="temperatureChart"></canvas>
            </div>

            <div class="chart-wrapper">
                <h3 class="chart-title">ğŸ“ˆ Produkcja energii dzienna - caÅ‚y okres</h3>
                <canvas id="productionChart"></canvas>
            </div>
        </div>
    </div>

    <script>
        // Dane i zmienne globalne
        let productionData = [];
        let storageHistory = [];
        let temperatureHistory = [];
        let lossHistory = []; // Historia dziennych strat przez izolacjÄ™
        let currentStorage = 0; // Akumulator zaczyna pusty (0 kWh)
        let currentTemperature = 20; // Temperatura otoczenia (20Â°C)
        let tankShape = 'box'; // KsztaÅ‚t: 'box' lub 'cylinder'
        let tankLength = 1; // DÅ‚ugoÅ›Ä‡ zbiornika w metrach (dla prostopadÅ‚oÅ›cianu)
        let tankWidth = 1; // SzerokoÅ›Ä‡ zbiornika w metrach (dla prostopadÅ‚oÅ›cianu)
        let tankHeight = 1; // WysokoÅ›Ä‡ zbiornika w metrach (dla prostopadÅ‚oÅ›cianu)
        let cylinderRadius = 0.564; // PromieÅ„ walca w metrach
        let cylinderHeight = 1; // WysokoÅ›Ä‡ walca w metrach
        let maxCapacity = 10000; // BÄ™dzie obliczana z wymiarÃ³w
        let insulationThickness = 200; // GruboÅ›Ä‡ izolacji w mm
        let pvScaling = 100; // Skalowanie produkcji PV w % (100% = peÅ‚na moc z pliku)
        let maxSandTemp = 600; // Maksymalna temperatura piasku w Â°C

        // Wykresy
        let productionChart, storageChart, lossChart, temperatureChart;

        // Inicjalizacja
        document.addEventListener('DOMContentLoaded', function() {
            initCharts();
            calculateCapacity(); // Oblicz pojemnoÅ›Ä‡ na starcie
            updateDisplay();

            // Automatyczne wczytanie pliku CSV z GitHuba
            loadDefaultCSV();

            // Event listener dla wyboru ksztaÅ‚tu
            document.getElementById('tankShape').addEventListener('change', function(e) {
                tankShape = e.target.value;

                // PokaÅ¼/ukryj odpowiednie pola
                if (tankShape === 'box') {
                    document.getElementById('boxDimensions').style.display = 'grid';
                    document.getElementById('cylinderDimensions').style.display = 'none';
                } else {
                    document.getElementById('boxDimensions').style.display = 'none';
                    document.getElementById('cylinderDimensions').style.display = 'grid';
                }

                calculateCapacity();
                if (productionData.length > 0) {
                    simulateFullPeriod();
                }
            });

            // Event listenery dla kontrolek prostopadÅ‚oÅ›cianu
            document.getElementById('tankLength').addEventListener('change', function(e) {
                tankLength = parseFloat(e.target.value);
                calculateCapacity();
                if (productionData.length > 0) {
                    simulateFullPeriod();
                }
            });

            document.getElementById('tankWidth').addEventListener('change', function(e) {
                tankWidth = parseFloat(e.target.value);
                calculateCapacity();
                if (productionData.length > 0) {
                    simulateFullPeriod();
                }
            });

            document.getElementById('tankHeight').addEventListener('change', function(e) {
                tankHeight = parseFloat(e.target.value);
                calculateCapacity();
                if (productionData.length > 0) {
                    simulateFullPeriod();
                }
            });

            // Event listenery dla wymiarÃ³w walca
            document.getElementById('cylinderRadius').addEventListener('change', function(e) {
                cylinderRadius = parseFloat(e.target.value);
                calculateCapacity();
                if (productionData.length > 0) {
                    simulateFullPeriod();
                }
            });

            document.getElementById('cylinderHeight').addEventListener('change', function(e) {
                cylinderHeight = parseFloat(e.target.value);
                calculateCapacity();
                if (productionData.length > 0) {
                    simulateFullPeriod();
                }
            });

            document.getElementById('insulationThickness').addEventListener('change', function(e) {
                insulationThickness = parseFloat(e.target.value);
                if (productionData.length > 0) {
                    simulateFullPeriod(); // Przelicz symulacjÄ™ z nowÄ… gruboÅ›ciÄ…
                }
            });

            document.getElementById('pvScaling').addEventListener('change', function(e) {
                pvScaling = parseFloat(e.target.value);
                if (productionData.length > 0) {
                    simulateFullPeriod(); // Przelicz symulacjÄ™ z nowym skalowaniem
                }
            });

            document.getElementById('maxSandTemp').addEventListener('change', function(e) {
                maxSandTemp = parseFloat(e.target.value);
                calculateCapacity(); // Przelicz pojemnoÅ›Ä‡ z nowÄ… temperaturÄ…
                if (productionData.length > 0) {
                    simulateFullPeriod(); // Przelicz symulacjÄ™
                }
            });
        });

        // Obliczanie pojemnoÅ›ci akumulatora z wymiarÃ³w
        function calculateCapacity() {
            // Obliczenie objÄ™toÅ›ci w zaleÅ¼noÅ›ci od ksztaÅ‚tu
            let volume;
            let dimensions;

            if (tankShape === 'box') {
                // ProstopadÅ‚oÅ›cian: V = dÅ‚ugoÅ›Ä‡ Ã— szerokoÅ›Ä‡ Ã— wysokoÅ›Ä‡
                volume = tankLength * tankWidth * tankHeight;
                dimensions = `${tankLength}m Ã— ${tankWidth}m Ã— ${tankHeight}m`;
            } else {
                // Walec: V = Ï€ Ã— rÂ² Ã— h
                volume = Math.PI * cylinderRadius * cylinderRadius * cylinderHeight;
                dimensions = `âŒ€${(cylinderRadius*2).toFixed(2)}m Ã— ${cylinderHeight}m (r=${cylinderRadius}m)`;
            }

            // Parametry fizyczne piasku
            const sandDensity = 1600; // kg/mÂ³ - gÄ™stoÅ›Ä‡ piasku
            const sandSpecificHeat = 0.835; // kJ/(kgÂ·K) - ciepÅ‚o wÅ‚aÅ›ciwe piasku
            const minTemp = 20; // Temperatura minimalna (otoczenia)
            const deltaT = maxSandTemp - minTemp; // RÃ³Å¼nica temperatur

            // Energia = masa Ã— ciepÅ‚o wÅ‚aÅ›ciwe Ã— Î”T
            const mass = volume * sandDensity; // kg
            const energyKJ = mass * sandSpecificHeat * deltaT; // kJ
            maxCapacity = energyKJ / 3600; // kWh (1 kWh = 3600 kJ)

            console.log(`KsztaÅ‚t: ${tankShape === 'box' ? 'ProstopadÅ‚oÅ›cian' : 'Walec'}`);
            console.log(`Wymiary: ${dimensions}`);
            console.log(`ObjÄ™toÅ›Ä‡: ${volume.toFixed(2)} mÂ³`);
            console.log(`Zakres temperatur: ${minTemp}Â°C - ${maxSandTemp}Â°C (Î”T = ${deltaT}K)`);
            console.log(`PojemnoÅ›Ä‡: ${maxCapacity.toFixed(2)} kWh`);
        }

        // Inicjalizacja wykresÃ³w
        function initCharts() {
            const chartOptions = {
                responsive: true,
                maintainAspectRatio: true,
                plugins: {
                    legend: {
                        display: true,
                        position: 'top'
                    }
                },
                scales: {
                    y: {
                        beginAtZero: true
                    }
                }
            };

            // Wykres produkcji
            const ctxProduction = document.getElementById('productionChart').getContext('2d');
            productionChart = new Chart(ctxProduction, {
                type: 'bar',
                data: {
                    labels: [],
                    datasets: [{
                        label: 'Produkcja energii (kWh)',
                        data: [],
                        backgroundColor: 'rgba(102, 126, 234, 0.6)',
                        borderColor: 'rgba(102, 126, 234, 1)',
                        borderWidth: 2
                    }]
                },
                options: chartOptions
            });

            // Wykres stanu akumulatora
            const ctxStorage = document.getElementById('storageChart').getContext('2d');
            storageChart = new Chart(ctxStorage, {
                type: 'line',
                data: {
                    labels: [],
                    datasets: [{
                        label: 'Stan akumulatora (kWh)',
                        data: [],
                        backgroundColor: 'rgba(79, 172, 254, 0.2)',
                        borderColor: 'rgba(79, 172, 254, 1)',
                        borderWidth: 3,
                        fill: true,
                        tension: 0.4
                    }]
                },
                options: chartOptions
            });

            // Wykres strat energii
            const ctxLoss = document.getElementById('lossChart').getContext('2d');
            lossChart = new Chart(ctxLoss, {
                type: 'bar',
                data: {
                    labels: [],
                    datasets: [{
                        label: 'Straty dzienne (kWh)',
                        data: [],
                        backgroundColor: 'rgba(244, 67, 54, 0.6)',
                        borderColor: 'rgba(244, 67, 54, 1)',
                        borderWidth: 2
                    }]
                },
                options: chartOptions
            });

            // Wykres temperatury (centrum, Å›rednia i przy Å›ciankach)
            const ctxTemp = document.getElementById('temperatureChart').getContext('2d');
            temperatureChart = new Chart(ctxTemp, {
                type: 'line',
                data: {
                    labels: [],
                    datasets: [{
                        label: 'Temperatura w centrum (Â°C)',
                        data: [],
                        backgroundColor: 'rgba(255, 107, 53, 0.2)',
                        borderColor: 'rgba(255, 107, 53, 1)',
                        borderWidth: 3,
                        fill: false,
                        tension: 0.4
                    }, {
                        label: 'Åšrednia temperatura piasku (Â°C)',
                        data: [],
                        backgroundColor: 'rgba(76, 175, 80, 0.2)',
                        borderColor: 'rgba(76, 175, 80, 1)',
                        borderWidth: 2,
                        fill: false,
                        tension: 0.4,
                        borderDash: [5, 5]
                    }, {
                        label: 'Temperatura przy Å›ciankach (Â°C)',
                        data: [],
                        backgroundColor: 'rgba(33, 150, 243, 0.2)',
                        borderColor: 'rgba(33, 150, 243, 1)',
                        borderWidth: 2,
                        fill: true,
                        tension: 0.4,
                        borderDash: [10, 5]
                    }]
                },
                options: chartOptions
            });
        }

        // Automatyczne wczytanie domyÅ›lnego pliku CSV z GitHuba
        function loadDefaultCSV() {
            const defaultURL = 'https://raw.githubusercontent.com/piotreq7/SandAccumulatorCalculator/main/daily%20stats%2010kw.csv';

            console.log('Wczytywanie domyÅ›lnego pliku CSV z:', defaultURL);

            fetch(defaultURL)
                .then(response => {
                    if (!response.ok) {
                        throw new Error('Nie moÅ¼na pobraÄ‡ pliku CSV z GitHuba');
                    }
                    return response.text();
                })
                .then(csvText => {
                    console.log('âœ… PomyÅ›lnie pobrano plik CSV z GitHuba');
                    parseCSVData(csvText);
                })
                .catch(error => {
                    console.error('âŒ BÅ‚Ä…d wczytywania domyÅ›lnego pliku CSV:', error);
                    console.log('ğŸ’¡ UÅ¼ytkownik moÅ¼e wczytaÄ‡ plik rÄ™cznie za pomocÄ… przycisku "Wybierz plik CSV"');
                });
        }

        // Wczytanie pliku z dysku uÅ¼ytkownika
        function loadFromFile(event) {
            const file = event.target.files[0];
            if (!file) return;

            const reader = new FileReader();
            reader.onload = function(e) {
                const csvText = e.target.result;
                parseCSVData(csvText);
            };
            reader.onerror = function() {
                alert('âŒ BÅ‚Ä…d wczytywania pliku!');
            };
            reader.readAsText(file);
        }

        // Parsowanie danych CSV
        function parseCSVData(csvText) {
            Papa.parse(csvText, {
                header: true,
                skipEmptyLines: true,
                dynamicTyping: false,
                encoding: 'UTF-8',
                complete: function(results) {
                    console.log('Parsed results:', results);
                    console.log('First row:', results.data[0]);

                    // SprawdÅº jakie sÄ… nazwy kolumn
                    if (results.data.length > 0) {
                        console.log('Column names:', Object.keys(results.data[0]));
                    }

                    // Mapowanie danych z pliku CSV
                    // ZaÅ‚oÅ¼enie: pierwsza kolumna = data, druga kolumna = produkcja kWh
                    let rawData = results.data.map(row => {
                        const rowKeys = Object.keys(row);

                        // Pierwsza kolumna to data/czas
                        const dateKey = rowKeys[0] || '';
                        // Druga kolumna to produkcja
                        const productionKey = rowKeys[1] || '';

                        const dateValue = dateKey ? row[dateKey] : '';
                        const productionValue = productionKey ? row[productionKey] : '0';

                        return {
                            dateTime: String(dateValue).trim(),
                            production: parseFloat(productionValue) || 0,
                            hasDate: dateValue && String(dateValue).trim().length > 0
                        };
                    });

                    console.log('Mapped raw data (first 3):', rawData.slice(0, 3));

                    // Filtrowanie pustych wierszy
                    rawData = rawData.filter(d => !isNaN(d.production));

                    // AGREGACJA PER DZIEÅƒ: sprawdÅº czy dane zawierajÄ… timestamp (godziny)
                    // JeÅ›li tak, agreguj wartoÅ›ci dla tego samego dnia
                    const dailyAggregated = {};
                    let hasTimestamps = false;
                    const rowsWithoutDate = [];

                    rawData.forEach(row => {
                        if (!row.hasDate || row.dateTime.length === 0) {
                            // Zbierz wiersze bez daty (bÄ™dÄ… obsÅ‚uÅ¼one pÃ³Åºniej)
                            rowsWithoutDate.push(row);
                            return;
                        }

                        // WyciÄ…gnij samÄ… datÄ™ (bez godziny)
                        // Format moÅ¼e byÄ‡: "2025-07-29 20:37:03" lub "2025-07-29"
                        let dateOnly = row.dateTime.split(' ')[0].trim();

                        // SprawdÅº czy jest czas (godzina) w danych
                        if (row.dateTime.includes(':') || row.dateTime.includes(' ')) {
                            hasTimestamps = true;
                        }

                        // Agreguj wartoÅ›ci dla tego samego dnia
                        if (!dailyAggregated[dateOnly]) {
                            dailyAggregated[dateOnly] = 0;
                        }
                        dailyAggregated[dateOnly] += row.production;
                    });

                    // Konwersja zagregowanych danych do tablicy
                    productionData = Object.keys(dailyAggregated).map(date => ({
                        date: date,
                        production: dailyAggregated[date],
                        hasDate: true
                    }));

                    if (hasTimestamps) {
                        console.log(`âœ… Wykryto format z timestampami - zagregowano ${rawData.length - rowsWithoutDate.length} wpisÃ³w do ${productionData.length} dni`);
                    }

                    console.log('Aggregated data (first 3):', productionData.slice(0, 3));

                    // SprawdÅº czy sÄ… wiersze bez daty (nie zagregowane)
                    if (rowsWithoutDate.length > 0) {
                        console.warn(`âš ï¸ Znaleziono ${rowsWithoutDate.length} wierszy bez daty - generujÄ™ automatyczne daty!`);

                        // Dodaj wiersze bez dat jako osobne dni (produkcja per wiersz)
                        rowsWithoutDate.forEach(row => {
                            productionData.push({
                                date: '',  // Zostanie wygenerowana automatycznie
                                production: row.production,
                                hasDate: false
                            });
                        });
                    }


                    // Generuj automatyczne daty dla wierszy bez daty
                    let autoDateCounter = 0;
                    const today = new Date();
                    productionData = productionData.map((d, index) => {
                        if (!d.hasDate || d.date.length === 0) {
                            // Generuj datÄ™: dzisiaj - (dÅ‚ugoÅ›Ä‡_tablicy - index) dni
                            const autoDate = new Date(today);
                            autoDate.setDate(today.getDate() - (productionData.length - index - 1));
                            d.date = autoDate.toISOString().split('T')[0];
                            autoDateCounter++;
                        }
                        delete d.hasDate; // UsuÅ„ tymczasowe pole
                        return d;
                    });

                    if (autoDateCounter > 0) {
                        console.log(`âœ… Wygenerowano ${autoDateCounter} automatycznych dat`);
                    }

                    console.log('Filtered data length:', productionData.length);

                    // Sortowanie po dacie
                    productionData.sort((a, b) => new Date(a.date) - new Date(b.date));

                    // WypeÅ‚nij brakujÄ…ce dni (luki w datach) z produkcjÄ… 0 kWh
                    if (productionData.length > 1) {
                        const filledData = [];

                        for (let i = 0; i < productionData.length; i++) {
                            filledData.push(productionData[i]);

                            // SprawdÅº czy jest nastÄ™pny dzieÅ„
                            if (i < productionData.length - 1) {
                                const currentDate = new Date(productionData[i].date);
                                const nextDate = new Date(productionData[i + 1].date);

                                // Oblicz rÃ³Å¼nicÄ™ w dniach
                                const diffTime = nextDate - currentDate;
                                const diffDays = Math.floor(diffTime / (1000 * 60 * 60 * 24));

                                // JeÅ›li rÃ³Å¼nica > 1 dzieÅ„, wypeÅ‚nij brakujÄ…ce dni
                                if (diffDays > 1) {
                                    console.log(`ğŸ“… Znaleziono lukÄ™ ${diffDays} dni miÄ™dzy ${productionData[i].date} a ${productionData[i + 1].date}`);

                                    for (let j = 1; j < diffDays; j++) {
                                        const missingDate = new Date(currentDate);
                                        missingDate.setDate(currentDate.getDate() + j);

                                        filledData.push({
                                            date: missingDate.toISOString().split('T')[0],
                                            production: 0
                                        });
                                    }
                                }
                            }
                        }

                        const missingDaysCount = filledData.length - productionData.length;
                        if (missingDaysCount > 0) {
                            console.log(`âœ… Dodano ${missingDaysCount} brakujÄ…cych dni z produkcjÄ… 0 kWh`);
                            productionData = filledData;
                        }
                    }

                    if (productionData.length > 0) {
                        // Generuj wykresy TYLKO dla rzeczywistych danych z CSV
                        updateProductionChart();
                        simulateFullPeriod();

                        const totalProduction = productionData.reduce((sum, d) => sum + d.production, 0);
                        const avgProduction = totalProduction / productionData.length;
                        const totalLoss = lossHistory.reduce((sum, d) => sum + d.loss, 0);
                        const avgLoss = totalLoss / lossHistory.length;

                        const volume = tankShape === 'box'
                            ? tankLength * tankWidth * tankHeight
                            : Math.PI * cylinderRadius * cylinderRadius * cylinderHeight;

                        const dimensions = tankShape === 'box'
                            ? `${tankLength}m Ã— ${tankWidth}m Ã— ${tankHeight}m`
                            : `âŒ€${(cylinderRadius*2).toFixed(2)}m Ã— ${cylinderHeight}m (r=${cylinderRadius}m)`;

                        const avgSandPath = tankShape === 'box'
                            ? (tankLength + tankWidth + tankHeight) / 6
                            : (cylinderRadius + cylinderHeight / 2) / 2;

                        // Oblicz okres w latach
                        const startDate = new Date(productionData[0].date);
                        const endDate = new Date(productionData[productionData.length-1].date);
                        const periodYears = (endDate - startDate) / (365.25 * 24 * 60 * 60 * 1000);

                        // Oblicz rzeczywistÄ… moc instalacji po przeskalowaniu
                        const nominalPower = 12; // kW (z pliku)
                        const scaledPower = nominalPower * (pvScaling / 100);

                        // Komunikat o automatycznych datach (jeÅ›li byÅ‚y generowane)
                        const autoDateInfo = autoDateCounter > 0
                            ? `\nâš ï¸ Uwaga: ${autoDateCounter} wierszy nie miaÅ‚o daty - wygenerowano automatycznie.`
                            : '';

                        // Komunikat o wypeÅ‚nionych brakujÄ…cych dniach (jeÅ›li byÅ‚y luki)
                        const originalDataCount = Object.keys(dailyAggregated).length;
                        const missingDaysCount = productionData.length - originalDataCount - autoDateCounter;
                        const missingDaysInfo = missingDaysCount > 0
                            ? `\nğŸ“… UzupeÅ‚niono ${missingDaysCount} brakujÄ…cych dni (luki w datach) z produkcjÄ… 0 kWh.`
                            : '';

                        // Informacja o agregacji (jeÅ›li byÅ‚y timestampy)
                        const aggregatedCount = rawData.length - rowsWithoutDate.length;
                        const aggregationInfo = hasTimestamps
                            ? `\nğŸ”„ Wykryto format z timestampami - zagregowano ${aggregatedCount} wpisÃ³w do ${Object.keys(dailyAggregated).length} dni.`
                            : '';

                        alert(`âœ… Wczytano ${productionData.length} dni danych produkcji energii!${aggregationInfo}${autoDateInfo}${missingDaysInfo}\n` +
                              `Okres: ${productionData[0].date} - ${productionData[productionData.length-1].date}\n` +
                              `Czas trwania: ${periodYears.toFixed(2)} lat\n\n` +
                              `Akumulator:\n` +
                              `KsztaÅ‚t: ${tankShape === 'box' ? 'ProstopadÅ‚oÅ›cian' : 'Walec'}\n` +
                              `Wymiary: ${dimensions}\n` +
                              `ObjÄ™toÅ›Ä‡: ${volume.toFixed(2)} mÂ³\n` +
                              `Zakres temperatur: 20-${maxSandTemp}Â°C\n` +
                              `PojemnoÅ›Ä‡: ${maxCapacity.toFixed(2)} kWh\n` +
                              `Åšr. droga ciepÅ‚a przez piasek: ${(avgSandPath*1000).toFixed(0)} mm\n\n` +
                              `Instalacja PV:\n` +
                              `Moc nominalna (z pliku): ${nominalPower} kW\n` +
                              `Skalowanie: ${pvScaling}%\n` +
                              `Rzeczywista moc: ${scaledPower.toFixed(2)} kW\n\n` +
                              `Produkcja (z pliku, przed skalowaniem):\n` +
                              `Åšrednia dzienna: ${avgProduction.toFixed(2)} kWh/dzieÅ„\n` +
                              `CaÅ‚kowita: ${totalProduction.toFixed(2)} kWh\n\n` +
                              `Produkcja (po skalowaniu ${pvScaling}%):\n` +
                              `Åšrednia dzienna: ${(avgProduction * pvScaling / 100).toFixed(2)} kWh/dzieÅ„\n` +
                              `CaÅ‚kowita: ${(totalProduction * pvScaling / 100).toFixed(2)} kWh\n\n` +
                              `Straty (piasek + izolacja ${insulationThickness}mm):\n` +
                              `Åšrednie dzienne: ${avgLoss.toFixed(2)} kWh/dzieÅ„\n` +
                              `CaÅ‚kowite: ${totalLoss.toFixed(2)} kWh\n\n` +
                              `Stan koÅ„cowy: ${currentStorage.toFixed(2)} kWh (${(currentStorage/maxCapacity*100).toFixed(1)}%)`);
                    } else {
                        console.error('No data after filtering. Raw results:', results);
                        alert('âš ï¸ Nie znaleziono danych w pliku CSV.\n\n' +
                              'SprawdÅº konsolÄ™ przeglÄ…darki (F12) aby zobaczyÄ‡ szczegÃ³Å‚y.');
                        productionData = [];
                    }
                },
                error: function(error) {
                    console.error('BÅ‚Ä…d parsowania CSV:', error);
                    alert('âŒ BÅ‚Ä…d parsowania pliku CSV. SprawdÅº format pliku.\n\nSzczegÃ³Å‚y w konsoli (F12).');
                }
            });
        }


        // Aktualizacja wykresu produkcji
        function updateProductionChart() {
            // Pokazuj caÅ‚y okres z pliku CSV
            productionChart.data.labels = productionData.map(d => d.date);
            productionChart.data.datasets[0].data = productionData.map(d => d.production);
            productionChart.update();
        }

        // Obliczanie dziennych strat energii przez izolacjÄ™
        function calculateDailyLoss(temperature, insulationThicknessMm) {
            // MODEL FIZYCZNY STRAT CIEPÅA:
            // CiepÅ‚o musi przejÅ›Ä‡ przez dwie warstwy (opornoÅ›ci szeregowo):
            // 1. PIASEK (wewnÄ…trz zbiornika) - gorsze przewodzenie ciepÅ‚a
            // 2. IZOLACJA (na zewnÄ…trz) - lepsze wÅ‚aÅ›ciwoÅ›ci izolacyjne
            //
            // Gradient temperatury w piasku:
            // - W centrum zbiornika: temperatura maksymalna (podana w parametrze)
            // - Przy Å›ciankach: temperatura niÅ¼sza (zaleÅ¼y od opornoÅ›ci piasku)
            // - CiepÅ‚o rozprzestrzenia siÄ™ od centrum do wszystkich 6 Å›cian
            //
            // Lambda (przewodnoÅ›Ä‡ cieplna):
            // - Piasek: 0.27 W/(mÂ·K) - GORSZY izolator (ciepÅ‚o Å‚atwiej przepÅ‚ywa)
            // - WeÅ‚na: 0.04 W/(mÂ·K) - LEPSZY izolator (ok. 6-7Ã— lepsza niÅ¼ piasek)

            // Parametry fizyczne
            const ambientTemp = 20; // Temperatura otoczenia (Â°C)
            const lambdaInsulation = 0.04; // WspÃ³Å‚czynnik przewodzenia ciepÅ‚a izolacji (W/mÂ·K) - weÅ‚na mineralna
            const lambdaSand = 0.27; // WspÃ³Å‚czynnik przewodzenia ciepÅ‚a piasku (W/mÂ·K) - piasek suchy

            // Konwersja gruboÅ›ci z mm na m
            const thicknessM = insulationThicknessMm / 1000;

            // Obliczanie ÅšREDNIEJ DROGI ciepÅ‚a przez piasek do Å›cianek
            // ZaleÅ¼y od ksztaÅ‚tu zbiornika
            let avgSandPath;

            if (tankShape === 'box') {
                // ProstopadÅ‚oÅ›cian: Å›rednia droga to 1/6 sumy wymiarÃ³w
                avgSandPath = (tankLength + tankWidth + tankHeight) / 6;
            } else {
                // Walec: Å›rednia droga = (promieÅ„ + wysokoÅ›Ä‡/2) / 2
                avgSandPath = (cylinderRadius + cylinderHeight / 2) / 2;
            }

            // Dla maÅ‚ych zbiornikÃ³w droga jest krÃ³tsza (mniejszy opÃ³r piasku)
            // Dla duÅ¼ych zbiornikÃ³w droga jest dÅ‚uÅ¼sza (wiÄ™kszy opÃ³r piasku)

            // Wymiary zewnÄ™trzne izolacji - zaleÅ¼Ä… od ksztaÅ‚tu
            // UWAGA: Podstawa ma 4Ã— grubszÄ… izolacjÄ™ (konstrukcyjna)
            const baseThicknessM = thicknessM * 4;

            let baseArea, wallsArea, topArea;
            let baseAreaOuter, wallsTopAreaOuter;

            if (tankShape === 'box') {
                // ProstopadÅ‚oÅ›cian
                const outerLength = tankLength + 2 * thicknessM;
                const outerWidth = tankWidth + 2 * thicknessM;

                baseArea = tankLength * tankWidth;
                wallsArea = 2 * (tankLength * tankHeight + tankWidth * tankHeight);
                topArea = tankLength * tankWidth;

                baseAreaOuter = outerLength * outerWidth;
                wallsTopAreaOuter = 2 * (outerLength * outerWidth + outerLength * tankHeight + outerWidth * tankHeight);
            } else {
                // Walec
                const outerRadius = cylinderRadius + thicknessM;

                baseArea = Math.PI * cylinderRadius * cylinderRadius; // Podstawa (koÅ‚o)
                wallsArea = 2 * Math.PI * cylinderRadius * cylinderHeight; // PÅ‚aszcz boczny
                topArea = Math.PI * cylinderRadius * cylinderRadius; // GÃ³ra (koÅ‚o)

                baseAreaOuter = Math.PI * (cylinderRadius + baseThicknessM) * (cylinderRadius + baseThicknessM);
                wallsTopAreaOuter = 2 * Math.PI * outerRadius * cylinderHeight + Math.PI * outerRadius * outerRadius;
            }

            // Åšrednie powierzchnie dla przewodzenia (geometryczna Å›rednia wew. i zew.)
            const avgBaseArea = Math.sqrt(baseArea * baseAreaOuter);
            const wallsTopAreaInner = wallsArea + topArea;
            const avgWallsTopArea = Math.sqrt(wallsTopAreaInner * wallsTopAreaOuter);

            // RÃ³Å¼nica temperatur
            const deltaT = temperature - ambientTemp;

            if (deltaT <= 0) {
                return 0; // Brak strat jeÅ›li temp <= otoczenia
            }

            // Obliczanie OPORNOÅšCI TERMICZNYCH (szeregowo poÅ‚Ä…czone)
            // R = d / (lambda * A)

            // OpornoÅ›Ä‡ termiczna piasku (dla caÅ‚ego zbiornika)
            const R_sand = avgSandPath / (lambdaSand * (avgBaseArea + avgWallsTopArea));

            // OpornoÅ›Ä‡ termiczna izolacji - OSOBNO dla podstawy i Å›cian
            // Podstawa: 4Ã— grubsza izolacja (konstrukcyjna)
            const effectiveBaseThickness = baseThicknessM > 0 ? baseThicknessM : 0.004; // min 4mm
            const R_insulation_base = effectiveBaseThickness / (lambdaInsulation * avgBaseArea);

            // Åšciany i gÃ³ra: normalna gruboÅ›Ä‡
            const effectiveThickness = thicknessM > 0 ? thicknessM : 0.001; // min 1mm
            const R_insulation_walls = effectiveThickness / (lambdaInsulation * avgWallsTopArea);

            // CaÅ‚kowita opornoÅ›Ä‡ termiczna (rÃ³wnolegÅ‚e poÅ‚Ä…czenie podstawy i Å›cian)
            // 1/R_total = 1/R_base + 1/R_walls
            // gdzie R_base = R_sand + R_insulation_base (szeregowo)
            // i R_walls = R_sand + R_insulation_walls (szeregowo)

            // Uproszczenie: zakÅ‚adamy Å¼e piasek ma jednÄ… wspÃ³lnÄ… opornoÅ›Ä‡
            // a izolacje sÄ… rÃ³wnolegle (podstawa || Å›ciany)
            const R_insulation_parallel = 1 / (1/R_insulation_base + 1/R_insulation_walls);
            const R_total = R_sand + R_insulation_parallel;

            // Obliczanie strat cieplnych (W)
            // Q = Î”T / R_total
            const heatLoss = deltaT / R_total;

            // Konwersja na energiÄ™ dziennÄ… (kWh)
            // P[W] * 24h / 1000 = kWh
            return (heatLoss * 24) / 1000;
        }

        // Obliczanie Å›redniej temperatury piasku z uwzglÄ™dnieniem gradientu
        function calculateAverageSandTemperature(centerTemp) {
            // MODEL GRADIENTU TEMPERATUR W PIASKU:
            // W centrum zbiornika: temperatura maksymalna (centerTemp)
            // Przy Å›ciankach: temperatura niÅ¼sza (zaleÅ¼y od opornoÅ›ci piasku i izolacji)
            //
            // Dla prostopadÅ‚oÅ›cianu zakÅ‚adamy rozkÅ‚ad paraboliczny temperatury
            // od centrum do Å›cianek. Åšrednia temperatura jest niÅ¼sza niÅ¼ w centrum.
            //
            // Uproszczony model: T_avg = T_center - (gradient Ã— Å›rednia_droga/2)
            // gdzie gradient zaleÅ¼y od strat ciepÅ‚a

            const ambientTemp = 20;
            const deltaT = centerTemp - ambientTemp;

            if (deltaT <= 0) {
                return {
                    center: centerTemp,
                    average: centerTemp,
                    wall: centerTemp
                };
            }

            // Obliczanie gradientu temperatury w piasku
            // Im wiÄ™ksze straty, tym wiÄ™kszy gradient
            let avgSandPath;

            if (tankShape === 'box') {
                avgSandPath = (tankLength + tankWidth + tankHeight) / 6;
            } else {
                avgSandPath = (cylinderRadius + cylinderHeight / 2) / 2;
            }

            const thicknessM = insulationThickness / 1000;
            const baseThicknessM = thicknessM * 4;
            const lambdaSand = 0.27;
            const lambdaInsulation = 0.04;

            // Obliczamy powierzchnie - jak w calculateDailyLoss
            let baseArea, wallsArea, topArea;
            let baseAreaOuter, wallsTopAreaOuter;

            if (tankShape === 'box') {
                const outerLength = tankLength + 2 * thicknessM;
                const outerWidth = tankWidth + 2 * thicknessM;

                baseArea = tankLength * tankWidth;
                wallsArea = 2 * (tankLength * tankHeight + tankWidth * tankHeight);
                topArea = tankLength * tankWidth;

                baseAreaOuter = outerLength * outerWidth;
                wallsTopAreaOuter = 2 * (outerLength * outerWidth + outerLength * tankHeight + outerWidth * tankHeight);
            } else {
                const outerRadius = cylinderRadius + thicknessM;

                baseArea = Math.PI * cylinderRadius * cylinderRadius;
                wallsArea = 2 * Math.PI * cylinderRadius * cylinderHeight;
                topArea = Math.PI * cylinderRadius * cylinderRadius;

                baseAreaOuter = Math.PI * (cylinderRadius + baseThicknessM) * (cylinderRadius + baseThicknessM);
                wallsTopAreaOuter = 2 * Math.PI * outerRadius * cylinderHeight + Math.PI * outerRadius * outerRadius;
            }

            const avgBaseArea = Math.sqrt(baseArea * baseAreaOuter);
            const wallsTopAreaInner = wallsArea + topArea;
            const avgWallsTopArea = Math.sqrt(wallsTopAreaInner * wallsTopAreaOuter);

            // OpornoÅ›ci
            const R_sand = avgSandPath / (lambdaSand * (avgBaseArea + avgWallsTopArea));

            const effectiveBaseThickness = baseThicknessM > 0 ? baseThicknessM : 0.004;
            const R_insulation_base = effectiveBaseThickness / (lambdaInsulation * avgBaseArea);

            const effectiveThickness = thicknessM > 0 ? thicknessM : 0.001;
            const R_insulation_walls = effectiveThickness / (lambdaInsulation * avgWallsTopArea);

            const R_insulation_parallel = 1 / (1/R_insulation_base + 1/R_insulation_walls);
            const R_total = R_sand + R_insulation_parallel;

            // StrumieÅ„ ciepÅ‚a
            const heatFlow = deltaT / R_total; // W

            // Spadek temperatury w warstwie piasku
            // Î”T_sand = Q Ã— R_sand
            const tempDropInSand = heatFlow * R_sand;

            // Temperatura przy Å›ciankach wewnÄ™trznych zbiornika (przed izolacjÄ…)
            const wallTemp = centerTemp - tempDropInSand;

            // Åšrednia temperatura w piasku (rozkÅ‚ad paraboliczny)
            // Dla rozkÅ‚adu parabolicznego: T_avg = (2Ã—T_center + T_wall) / 3
            const avgTemp = (2 * centerTemp + wallTemp) / 3;

            // Zwracamy obiekt z trzema wartoÅ›ciami
            return {
                center: centerTemp,
                average: avgTemp,
                wall: wallTemp
            };
        }


        // Symulacja caÅ‚ego okresu
        function simulateFullPeriod() {
            storageHistory = [];
            temperatureHistory = [];
            lossHistory = [];
            currentStorage = 0; // Akumulator zaczyna pusty
            currentTemperature = 20; // Temperatura w centrum zbiornika

            // WspÃ³Å‚czynnik skalowania (100% = 1.0, 50% = 0.5, 200% = 2.0)
            const scalingFactor = pvScaling / 100;

            productionData.forEach((dayData) => {
                // Oblicz straty z poprzedniego dnia
                const dailyLoss = calculateDailyLoss(currentTemperature, insulationThickness);

                // Odejmij straty od akumulatora
                currentStorage -= dailyLoss;
                if (currentStorage < 0) currentStorage = 0;

                // Aktualizacja stanu akumulatora - produkcja przeskalowana
                const scaledProduction = dayData.production * scalingFactor;
                currentStorage += scaledProduction;

                // Ograniczenia pojemnoÅ›ci
                if (currentStorage > maxCapacity) {
                    currentStorage = maxCapacity;
                } else if (currentStorage < 0) {
                    currentStorage = 0;
                }

                // Obliczanie temperatury w centrum na podstawie poziomu naÅ‚adowania
                // To jest temperatura MAKSYMALNA (w centrum zbiornika)
                const storagePercentage = currentStorage / maxCapacity;
                const minTemp = 20; // Temperatura otoczenia
                const tempRange = maxSandTemp - minTemp; // Zakres temperatur
                currentTemperature = minTemp + (storagePercentage * tempRange); // np. 20 + (1.0 Ã— 580) = 600Â°C

                // Oblicz temperatury w rÃ³Å¼nych miejscach zbiornika (uwzglÄ™dnia gradient)
                const temperatures = calculateAverageSandTemperature(currentTemperature);

                storageHistory.push({
                    date: dayData.date,
                    storage: currentStorage
                });

                // Zapisujemy TRZY temperatury: centrum, Å›redniÄ… i przy Å›ciankach
                temperatureHistory.push({
                    date: dayData.date,
                    temperature: temperatures.center,      // temp. w centrum (max)
                    avgTemperature: temperatures.average,  // Å›rednia temp. w caÅ‚ym zbiorniku
                    wallTemperature: temperatures.wall     // temp. przy Å›ciankach (przed izolacjÄ…)
                });

                lossHistory.push({
                    date: dayData.date,
                    loss: dailyLoss
                });
            });

            updateStorageChart();
            updateLossChart();
            updateTemperatureChart();
            updateDisplay();
        }


        // Aktualizacja wykresu stanu akumulatora
        function updateStorageChart() {
            // Pokazuj caÅ‚y okres
            storageChart.data.labels = storageHistory.map(d => d.date);
            storageChart.data.datasets[0].data = storageHistory.map(d => d.storage);
            storageChart.update();
        }

        // Aktualizacja wykresu strat energii
        function updateLossChart() {
            // Pokazuj caÅ‚y okres
            lossChart.data.labels = lossHistory.map(d => d.date);
            lossChart.data.datasets[0].data = lossHistory.map(d => d.loss);
            lossChart.update();
        }

        // Aktualizacja wykresu temperatury
        function updateTemperatureChart() {
            // Pokazuj caÅ‚y okres - temperatura w centrum, Å›rednia i przy Å›ciankach
            temperatureChart.data.labels = temperatureHistory.map(d => d.date);
            temperatureChart.data.datasets[0].data = temperatureHistory.map(d => d.temperature); // centrum
            temperatureChart.data.datasets[1].data = temperatureHistory.map(d => d.avgTemperature); // Å›rednia
            temperatureChart.data.datasets[2].data = temperatureHistory.map(d => d.wallTemperature); // Å›cianki
            temperatureChart.update();
        }

        // Aktualizacja wyÅ›wietlania - minimalna funkcja
        function updateDisplay() {
            // Funkcja moÅ¼e byÄ‡ uÅ¼ywana w przyszÅ‚oÅ›ci
        }
    </script>
</body>
</html>

